
R version 3.3.2 (2016-10-31) -- "Sincere Pumpkin Patch"
Copyright (C) 2016 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin13.4.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> #The map family of functions applies a function to the elements of a data structure, usually a list or a vector. The function is evaluated once for each element of the vector with the vector element as the first argument to the function. The return value is the same kind if data structure (a list or vector) but with every element replaced by the result of the function being evaluated with the corresponding element as the argument to the function. In the purrr package the map() function returns a list , while the map_lgl(), map_chr(), and map_dbl()functions return vectors of logical values, strings, or numbers respectively. Let’s take a look at a few examples: 
> 
> library(purrr)
> 
> print("HELLO")
[1] "HELLO"
> 
> 
> 
> 
> map_chr(c(5, 4, 3, 2, 1), function(x)
+ 	                  {
+                              c("one", "two", "three", "four", "five")[x]
+                           })
[1] "five"  "four"  "three" "two"   "one"  
> 
> map_lgl(c(1, 2, 3, 4, 5), function(x){ x > 3})
[1] FALSE FALSE FALSE  TRUE  TRUE
> 
> map_dbl(c(1, 2, 3, 4, 5), function(x){x*10})
[1] 10 20 30 40 50
> 
> 
> #Think about evaluating each function above with just one of the arguments in the specified numeric vector, and then combining all of those function results into one vector.
> 
> #The map_if() function takes as its arguments a list or vector containing data, a predicate function, and then a function to be applied. A predicate function is a function that returns TRUE orFALSE for each element in the provided list or vector. In the case ofmap_if(): if the predicate functions evaluates to TRUE, then the function is applied to the corresponding vector element, however if the predicate function evaluates to FALSE then the function is not applied. The map_if() function always returns a list, so I’m piping the result of map_if() to unlist() so it look prettier:
> 
> map_if(1:5, function(x){
+                      x %% 2 == 0
+             },
+             function(y){
+                     y^2
+             }) %>% unlist()
[1]  1  4  3 16  5
> 
> #Notice how only the even numbers are squared, while the odd numbers are left alone.
> 
> #The map_at() function only applies the provided function to elements of a vector specified by their indexes. map_at() always returns a list so like before I’m piping the result to unlist():
> 
> map_at(seq(100, 500, 100), c(1, 3, 5), function(x){
+ 	         x - 10
+ 	    }) %>% unlist()
[1]  90 200 290 400 490
> 
> 
> #Like we expected to happen the providied function is only applied to the first, third, and fifth element of the vector provided.
> 
> #In each of the examples above we have only been mapping a function over one data structure, however you can map a function over two data structures with the map2() family of functions. The first two arguments should be two vectors of the same length, followed by a function which will be evaluated with an element of the first vector as the first argument and an element of the second vector as the second argument. For example:
> 
> 
> map2_chr(letters, 1:26, paste)
 [1] "a 1"  "b 2"  "c 3"  "d 4"  "e 5"  "f 6"  "g 7"  "h 8"  "i 9"  "j 10"
[11] "k 11" "l 12" "m 13" "n 14" "o 15" "p 16" "q 17" "r 18" "s 19" "t 20"
[21] "u 21" "v 22" "w 23" "x 24" "y 25" "z 26"
> 
> 
> #The pmap() family of functions is similar to map2(), however instead of mapping across two vectors or lists, you can map across any number of lists. The list argument is a list of lists that the function will map over, followed by the function that will applied:
> 
> pmap_chr(list(
+            list(1, 2, 3),
+ 	   list("one", "two", "three"),
+ 	   list("uno", "dos", "tres")
+ 	 ), 
+ 	 paste)
[1] "1 one uno"    "2 two dos"    "3 three tres"
> 
> # Mapping is a powerful technique for thinking about how to apply computational operations to your data.
> 
> 
> ##----------------------  REDUCE ---------------------- ##
> #List or vector reduction iteratively combines the first element of a vector with the second element of a vector, then that combined result is combined with the third element of the vector, and so on until the end of the vector is reached. The function to be applied should take at least two arguments. Where mapping returns a vector or a list, reducing should return a single value. Some examples usingreduce() are illustrated below:
> 
> reduce(c(1, 3, 5, 7), function(x, y)
+                       {
+ 	               message("x is ", x)
+ 		       message("y is ", y)
+ 		       message("")
+ 		       x + y
+ 	              })
x is 1
y is 3

x is 4
y is 5

x is 9
y is 7

[1] 16
> 
> #On the first iteration x has the value 1 and y has the value 3, then the two values are combined (they’re added together). On the second iteration x has the value of the result from the first iteration (4) and y has the value of the third element in the provided numeric vector (5). This process is repeated for each iteration. Here’s a similar example using string data:
> 
> 
> reduce(letters[1:4], function(x, y){
+ 	         message("x is ", x)
+ 		   message("y is ", y)
+ 		   message("")
+ 		     paste0(x, y)
+ 		      })
x is a
y is b

x is ab
y is c

x is abc
y is d

[1] "abcd"
> 
> 
> #By default reduce() starts with the first element of a vector and then the second element and so on. In contrast the reduce_right()function starts with the last element of a vector and then proceeds to the second to last element of a vector and so on:
> 
> reduce_right(letters[1:4], function(x, y){
+ 		       message("x is ", x)
+ 		         message("y is ", y)
+ 		         message("")
+ 			   paste0(x, y)
+ 		      })
x is d
y is c

x is dc
y is b

x is dcb
y is a

[1] "dcba"
> 
> 
> 
> 
> 
> proc.time()
   user  system elapsed 
  0.167   0.029   0.182 
